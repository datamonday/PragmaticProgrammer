# 二叉树

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

## 二叉树的递归遍历

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。



递归算法的三要素：

1. 确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. 确定终止条件
3. 确定单层递归的逻辑：确定每一层递归需要处理的信息。

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def traversal(root: TreeNode):
            if not root:
                return
            
            res.append(root.val)
            traversal(root.left)
            traversal(root.right)
            
            return res

        res = []
        traversal(root)
        return res
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def traversal(root):
            if not root:
                return

            traversal(root.left)
            res.append(root.val)
            traversal(root.right)
        
        res = []
        traversal(root)
        return res
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def traversal(root):
            if not root:
                return
            
            traversal(root.left)
            traversal(root.right)
            res.append(root.val)
        
        res = []
        traversal(root)

        return res
```

## 二叉树的迭代遍历

```python
class Solution:
    """迭代"""
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        
        if not root:
            return res

        
        stack = [root]

        while stack:
            node = stack.pop()
            res.append(node.val)

            if node.right:
                stack.append(node.right)
            
            if node.left:
                stack.append(node.left)
            
        return res
```

```python
class Solution:
    """迭代"""
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        if not root:
            return res

        stack = [root]

        while stack:
            node = stack.pop()
            res.append(node.val)

            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)

        return res[::-1]
```

```python
class Solution:
    """递归"""
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        if not root:
            return res

        stack = []

        # 遍历指针
        curr = root

        while curr or stack:
            # 先迭代访问最底层的左子树节点
            if curr:
                stack.append(curr)
                curr = curr.left
            # 到达最左节点后处理栈顶节点 
            else:
                curr = stack.pop()
                res.append(curr.val)

                curr = curr.right

        return res
```

## 二叉树的层序遍历

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度

层序遍历二叉树需要借助队列来实现，这种层序遍历的方式就是图论中的广度优先遍历，只不过我们应用在二叉树上，而栈的先进后出适合模拟深度优先遍历，也就是递归的逻辑。

![102二叉树的层序遍历](https://tva1.sinaimg.cn/large/008eGmZEly1gnad5itmk8g30iw0cqe83.gif)

```python
from collections import deque


class Solution:
    """二叉树层序遍历迭代解法"""

    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        results = []
        if not root:
            return res
        
        que = deque([root])
        
        while que:
            size = len(que)
            result = []
            
            for _ in range(size):
                cur = que.popleft()
                result.append(cur.val)
                
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
                    
            results.append(result)
            
        return results
```

## 107. 二叉树的层序遍历 II

> https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历**。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque


class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []

        queue = deque()
        queue.append(root)
        
        result = []

        while queue:
            one_layer = []
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                one_layer.append(node.val)
            
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(one_layer)

        return result[::-1]

        
```





## 226.翻转二叉树

> https://leetcode.cn/problems/invert-binary-tree/

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        """
        求解思路：递归
        - 从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。
        - 如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么只需要交换两棵子树的位置，即可完成以 
        - root 为根节点的整棵子树的翻转。
        """
        # 如果这棵树没有节点或者只有一个根节点则直接返回
        if not root or (not root.left and not root.right):
            return root

        # 递归地交换当前节点的左右子树
        root.left, root.right = root.right, root.left

        self.invertTree(root.left)
        self.invertTree(root.right)

        return root
```

## 100.相同的树

> https://leetcode.cn/problems/same-tree/

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        return self.compare(p, q)

    def compare(self, p, q):
        if not p and not q:
            return True
        elif not p and q:
            return False
        elif p and not q:
            return False
        elif p.val != q.val:
            return False


        left = self.compare(p.left, q.left)
        right = self.compare(p.right, q.right)

        res = left and right

        return res
```

## 101.对称二叉树

> https://leetcode.cn/problems/symmetric-tree/

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

求解思路：

要判断一棵二叉树是否对称，应该比较根节点的左子树与右子树是不是相互翻转的。在递归遍历过程中，比较的是两个子树的里侧和外侧的元素是否相等。因为要比较内侧和外侧节点是否相等，所以其中一棵树的遍历顺序是左右中，一棵树的遍历顺序是右左中。

![101. 对称二叉树1](https://img-blog.csdnimg.cn/20210203144624414.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return False
        else:
            return self.compare(root.left, root.right)

    def compare(self, left, right):
        # 首先排除空节点的情况
        if left is None and right is None:
            return True
        
        elif left is None and right is not None:
            return False

        elif left is not None and right is None:
            return False

        # 排除数值不相等的情况
        if left.val != right.val:
            return False

        inside = self.compare(left.right, right.left)
        otside = self.compare(left.left, right.right)

        is_same = inside and otside
        return is_same
```

## 104. 二叉树的最大深度(递归or迭代)

> https://leetcode.cn/problems/maximum-depth-of-binary-tree/

给定一个二叉树，找出其最大深度。**二叉树的深度为根节点到最远叶子节点的最长路径上的节点数**。**说明:** 叶子节点是指没有子节点的节点。

求解思路：

如果使用递归，使用前序遍历求解的是深度，使用后序遍历求解的是高度。而根节点的高度就是二叉树的最大深度，所以使用后序遍历求解二叉树的最大深度。

如果使用迭代，使用层序遍历计算，二叉树的最大深度就是二叉树的层数。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        return self.cal_max_depth(root)
    
    def cal_max_depth(curr):
        if not curr:
            return 0
        
        left_depth = self.cal_max_depth(curr.left)
        right_depth = self.cal_max_depth(curr.right)
        
        return max(left_depth, right_depth) + 1
```

```python
from collections import deque

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        depth = 0
        queue = deque()
        queue.append(root)
        
        while queue:
            size = len(queue)
            depth += 1
            for i in range(size):
                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
        return depth
```

## 559. N 叉树的最大深度(递归or迭代)

> https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/

给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

求解思路：

```py
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        
        depth = 0
        for i in range(len(root.children)):
            depth = max(depth, self.maxDepth(root.children[i]))
            
        return depth + 1
```

```python
from collections import deque

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        queue = deque()
        if root:
            queue.append(root)
        depth = 0
        
        while queue:
            size = len(queue)
            depth += 1
            
            for i in range(size):
                node = queue.popleft()
                for j in range(len(node.children)):
                    if node.children[j]:
                        queue.append(node.children[j])
        return depth
```

## 111. 二叉树的最小深度(递归or迭代)

> https://leetcode.cn/problems/minimum-depth-of-binary-tree/

给定一个二叉树，找出其最小深度。**最小深度是从根节点到最近叶子节点的最短路径上的节点数量**。**说明：**叶子节点是指没有子节点的节点。

求解思路：

遍历顺序上依然是**后序遍历**（因为要比较递归返回之后的结果），但在处理中间节点的逻辑上，最大深度很容易理解，最小深度可有一个误区，如图：

![111.二叉树的最小深度](https://img-blog.csdnimg.cn/20210203155800503.png)

- 如果左子树为空，右子树不为空，说明最小深度是 1+右子树的深度。
- 如果右子树为空，左子树不为空，说明最小深度是 1+左子树的深度。
- 最后，如果左右子树都不为空，则返回左右子树深度最小值+1。

求二叉树的最小深度和最大深度的主要区别在于处理左右孩子不为空的逻辑。

```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        
        min_depth = 10 ** 9
        
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth)
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth)
            
        return min_depth + 1
```

```python
from collections import deque


class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        if not root.left and not root.right:
            return 1
        
        queue = deque()
        queue.append(root)
        depth = 1
        while queue:
            for _ in range(len(queue)):
                node = queue.popleft()
                if not node.left and not node.right:
                    return depth
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                    
            depth += 1
        return depth
```

## 222. 完全二叉树的节点个数(递归or迭代)

> https://leetcode.cn/problems/count-complete-tree-nodes/

给你一棵 完全二叉树 的根节点 root，求出该树的节点个数。

完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。

求解思路：

递归遍历的顺序依然是后序（左右中）。

```python
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        
        return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

```python
from collections import deque


class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = deque()
        queue.append(root)
        number = 0
        
        while queue:n n
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                
                number += 1
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
		return result
```

## 110. 平衡二叉树

> https://leetcode.cn/problems/balanced-binary-tree/

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 。

**求解思路**：

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

![110.平衡二叉树2](https://img-blog.csdnimg.cn/20210203155515650.png)

二叉树的最大深度，也用的是后序遍历。那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False
        
    def get_height(root) -> int:
        if not root:
            return 0
        
        left_height = self.get_height(root.left)
        if left_height == -1:
            return -1
        
        right_height = self.get_height(root.right)
        if right_height == -1:
            return -1
        
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
```

## 257. 二叉树的所有路径(隐形回溯)

> https://leetcode.cn/problems/binary-tree-paths/

给你一个二叉树的根节点 root，按任意顺序，返回所有从根节点到叶子节点的路径。叶子节点是指没有子节点的节点。

> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```

求解思路：

这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。

在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退，一个路径再进入另一个路径。

前序遍历以及回溯的过程如图：

![257.二叉树的所有路径](https://img-blog.csdnimg.cn/20210204151702443.png)

我们先使用递归的方式，来做前序遍历。要知道递归和回溯就是一家的，本题也需要回溯。隐形回溯：**回溯隐藏在函数调用时的参数赋值 path + "->" 里**。每次函数调用完，path依然是没有加上 "->" 的，这就是回溯了。

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def mock_paths(root, path):
            if root:
                path += str(root.val)
                # 遍历到叶节点
               	if not root.left and not root.right:
                    paths.append(path)
                else:
                    path += "->"
                    mock_paths(root.left, path)
                    mock_paths(root.right, path)
        paths = []
        mock_paths(root, "")
        return paths
```

## 404. 左叶子之和(隐形回溯)

> https://leetcode.cn/problems/sum-of-left-leaves/

给定二叉树的根节点 `root`，返回所有左叶子之和。

求解思路：

本题目的重点的是如何形式化的定义左叶子？即如果某个节点的左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是叶子节点。通过下面的例子加深理解：

![404.左叶子之和](https://img-blog.csdnimg.cn/20210204151949672.png)

上面这棵二叉树的左叶子之和其实是0，因为这棵树根本没有左叶子！

那么判断当前节点是不是左叶子是无法判断的，**必须要通过节点的父节点来判断其左孩子是不是左叶子**。

**如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子**。

递归三部曲：

1. 确定递归函数的参数和返回值：传入树的根节点，递归函数的返回值为数值之和，使用题目给出的函数即可。
2. 确定终止条件。
3. 确定单层递归的逻辑：当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和以及右子树左叶子之和，最后二者相加便是整个树的左叶子之和。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0

        cur_left_leaf_sum = 0
        if root.left and not root.left.left and not root.left.right:
            cur_left_leaf_sum = root.left.val
        
        left_sum = self.sumOfLeftLeaves(root.left)
        right_sum = self.sumOfLeftLeaves(root.right)

        return cur_left_leaf_sum + left_sum + right_sum   
```



## 513. 找树左下角的值

> https://leetcode.cn/problems/find-bottom-left-tree-value/

给定一个二叉树的根节点 root，请找出该二叉树的最底层最左边节点的值。假设二叉树中至少有一个节点。

求解思路：

层序遍历，保存最后一次遍历的队列中第一个节点。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        if not root:
            return None

        bottom_left_node = None

        queue = deque()
        queue.append(root)
        while queue:
            size = len(queue)
            for i in range(size):
                
                if i == 0:
                    bottom_left_node = queue[i].val

                node = queue.popleft()
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
        return bottom_left_node
```

## 112. 路径总和(回溯)

>https://leetcode.cn/problems/path-sum/

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false。叶子节点是指没有子节点的节点。

求解思路：

1. 确定递归函数的参数和返回类型：需要二叉树的根节点以及一个计数器，这个计数器用来计算二叉树的一条边之和时候正好是目标和，计数器为int类型。

递归函数什么时候需要返回值》什么时候不需要返回值？有三点需要注意：

- 如果需要搜索整棵二叉树且不需要处理递归返回值，则不需要返回值。
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。
- 如果需要搜索其中一条符合条件的路径， 那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。

本题需要找一条符合条件的路径，所以递归函数需要返回值。

![112.路径总和](https://img-blog.csdnimg.cn/2021020316051216.png)

图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。

2. 确定终止条件：可以让计数器初始值为目标和，然后每次减去遍历路径结点上的数值。如果最后count==0并且到达叶子结点，则说明找到了目标和；如果遍历到了叶子结点，count不为0，则没找到。
3. 确定单层递归的逻辑：因为终止条件是判断叶子节点，所以递归的过程中不要让空节点进入递归。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        def traversial(node, residual):
            # 到达叶节点，但是和不等于目标和
            if (not node.left) and (not node.right) and residual == 0:
                return True
            # 到达叶节点，和等于目标和
            if (not node.left) and (not node.right):
                return False

            if node.left:
                residual -= node.left.val
                if traversial(node.left, residual):
                    return True
                residual += node.left.val  # 回溯
            
            if node.right:
                residual -= node.right.val
                if traversial(node.right, residual):
                    return True
                residual += node.right.val  # 回溯

            return False

        if root == None:
            return False
        else:
            return traversial(root, targetSum - root.val)

```

## 113. 路径总和 II(回溯)

> https://leetcode.cn/problems/path-sum-ii/

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点是指没有子节点的节点。

求解思路：

路径总和ii要遍历整个树，找到所有路径，所以递归函数不要返回值！

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from copy import deepcopy


class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def traversial(node, residual):
            if not node.left and not node.right:  # 到达叶节点
                if residual == 0:
                    all_path.append(deepcopy(path))  # 深拷贝，否则结果不对
                else:
                    return None
            
            if node.left:
                path.append(node.left.val)
                traversial(node.left, residual - node.left.val)
                path.pop()  # 回溯

            if node.right:
                path.append(node.right.val)
                traversial(node.right, residual - node.right.val)
                path.pop()  # 回溯

        if not root:
            return []

        path = []
        all_path = []

        path.append(root.val)
        traversial(root, targetSum - root.val)

        return all_path
```

## 105. 从前序与中序遍历序列构造二叉树

> https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

求解思路：与106题类似。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # 1) 树为空，递归终止条件
        if not preorder:
            return None
        
        # 2) 前序遍历的第一个结点为当前的中间结点
        root_val = preorder[0]
        root = TreeNode(root_val)

        # 3) 寻找切割点
        separator_idx = inorder.index(root_val)

        # 4) 切割inorder数组，得到inorder数组的左、右半边
        inorder_left = inorder[:separator_idx]
        inorder_right = inorder[separator_idx+1:]

        # 5) 切割preorder数组，得到preorder数组的左、右半边
        preorder_left = preorder[1:1+len(inorder_left)]
        preorder_right = preorder[1+len(inorder_left):]

        # 6) 递归
        root.left = self.buildTree(preorder_left, inorder_left)
        root.right = self.buildTree(preorder_right, inorder_right)

        return root
```

## 106. 从中序与后序遍历序列构造二叉树

> https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

求解思路：根据后序数组中最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。

![106.从中序与后序遍历序列构造二叉树](https://img-blog.csdnimg.cn/20210203154249860.png)

递归实现：

- 1）如果数组大小为0，说明是空节点；
- 2）如果数组不为空，则取后序数组最后一个元素作为节点元素；
- 3）找到后序数组最后一个元素在中序数组的位置，作为中序数组的切割点；
- 4）切割中序数组，切成中序左数组和中序右数组；
- 5）切割后序数组，切成后序左数组和后序右数组；
- 6）递归处理左区间和右区间。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # 1) 递归中止条件
        if not postorder:
            return None

        # 2) 后序遍历的最后一个就是当前的中间结点
        root_val = postorder[-1]
        root = TreeNode(root_val)

        # 3) 找切割点
        separator_idx = inorder.index(root_val)

        # 4) 切割inorder数组
        inorder_left = inorder[:separator_idx]
        inorder_right = inorder[separator_idx+1:]

        # 5) 切割postorder数组
        postorder_left = postorder[:len(inorder_left)]
        postorder_right = postorder[len(inorder_left):-1]

        # 6) 递归
        root.left = self.buildTree(inorder_left, postorder_left)
        root.right = self.buildTree(inorder_right, postorder_right)

        return root
```



## 654. 最大二叉树

> https://leetcode.cn/problems/maximum-binary-tree/

给定一个不重复的整数数组 nums。 最大二叉树可以用下面的算法从 nums 递归地构建:

1. 创建一个根节点，其值为 nums 中的最大值。
2. 递归地在最大值 左边 的 子数组前缀上 构建左子树。
3. 递归地在最大值 右边 的 子数组后缀上 构建右子树。

返回 nums 构建的 最大二叉树 。

求解思路：

**构造树一般采用的是前序遍历，先构造中间节点，然后递归构造左子树和右子树**。

1. 确定递归函数的参数和返回值：参数就是传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。
2. 确定终止条件：题目说明了输入的数组大小>=1，所以不用考虑<1的情况。当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。这表示一个数组大小是1的时候，构造了一个新的节点，并返回。
3. 确定单层递归的逻辑：
   - 先找到数组中最大的值和对应的下标，最大的值构造根节点，下标用来下一步分割数组；
   - 最大值所在的下标左区间构造左子树；
   - 最大值所在的下标右区间构造右子树。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        if not nums:
            return None
        
        max_val = max(nums)
        val_idx = nums.index(max_val)

        root = TreeNode(max_val)

        left = nums[:val_idx]
        right = nums[val_idx+1:]

        root.left = self.constructMaximumBinaryTree(left)
        root.right = self.constructMaximumBinaryTree(right)

        return root
```

## 617. 合并二叉树

> https://leetcode.cn/problems/merge-two-binary-trees/

给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

求解思路：

同时遍历两棵二叉树？其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。

1. 确定递归函数的参数和返回值：合并两棵二叉树需要传入两棵二叉树的根节点，返回合并之后的结点。
2. 确定终止条件：两棵树遍历结点分别为t1和t2，如果t1==null，则两棵树的合并结果为t2；反之为t1；
3. 确定单层递归的逻辑：重复利用t1这棵树，t1就是合并之后树的根节点（修改了原来树的结构）。结点的值为两棵树的结点值相加。接下来，递归左子树，递归右子树。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1

        root1.val += root2.val

        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)

        return root1
```

## 700. 二叉搜索树中的搜索

> https://leetcode.cn/problems/search-in-a-binary-search-tree/

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

二叉搜索树：

- 若它的左子树不为空，则左子树上所有节点的值均小于它根节点的值；
- 若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值；
- 它的左、右子树也分别为二叉搜索树。

求解思路：

本题是要在二叉搜索树中搜索一个节点，可以使用递归进行遍历：

1. 确定函数的参数和返回值：递归函数的参数是根节点和目标值，返回值是目标值所在的节点。
2. 确定终止条件：如果root为空，或者找到这个数值了，就返回root节点。
3. 确定单层递归的逻辑：**二叉搜索树的节点是有序的，所以可以有方向的去搜索**。如果root->val > val，搜索左子树，如果root->val < val，就搜索右子树，最后如果都没有搜索到，就返回NULL。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root or root.val == val:
            return root

        if root.val > val:
            return self.searchBST(root.left, val)
        if root.val < val:
            return self.searchBST(root.right, val)
```

## 98.验证二叉搜索树

> https://leetcode.cn/problems/validate-binary-search-tree/

给你一个二叉树的根节点 root，判断其是否是一个有效的二叉搜索树。

有效二叉搜索树定义如下：

- 节点的左子树只包含 小于 当前节点的数。
- 节点的右子树只包含 大于 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

求解思路：中序遍历二叉搜索树，输出的节点序列是递增的有序序列。可以利用这个特性进行判断。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def inorder_bst(root):
            if not root:
                return False
            
            inorder_bst(root.left)
            res.append(root.val)
            inorder_bst(root.right)

        def is_bst(array):
            for i in range(len(array) - 1):
                if array[i] >= array[i+1]:
                    return False
            
            return True

        res = []
        inorder_bst(root)

        return is_bst(res)

```

## 530.二叉搜索树的最小绝对差

> https://leetcode.cn/problems/minimum-absolute-difference-in-bst/

给你一个二叉搜索树的根节点 root，返回树中任意两不同节点值之间的最小差值。

差值是一个正数，其数值等于两值之差的绝对值。

![img](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)



求解思路：

二叉搜索树的中序遍历是递增的有序数组，利用这个性质，题目可以转化为：求有序数组中任意两个数的最小绝对差。如此，便可以将问题简化。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:

        def inorder_bst(root):
            if not root:
                return None
            
            inorder_bst(root.left)
            res.append(root.val)
            inorder_bst(root.right)

        res = []
        inorder_bst(root)

        if len(res) == 1:
            return res[0]

        min_abs_val = float("inf")

        for i in range(len(res) - 1):
            min_abs_val = min(min_abs_val, abs(res[i+1] - res[i]))

        return min_abs_val
```

## 501.二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

求解思路：

1. 暴力解法：中序遍历二叉搜索树存储到数组中，遍历数组，使用字典统计各元素出现次数。
2. 使用二叉搜索树的性质进行优化：一棵二叉搜索树的中序遍历序列是一个非递减的有序序列。

顺序扫描中序遍历序列，

- 用 base 记录当前的数字
- 用 count 记录当前数字重复的次数
- 用 maxCount 维护已经扫描过的数当中出现最多的那个数字的出现次数
- 用 answer 数组记录出现的众数

每次扫描到一个新的元素：

- 首先更新 base 和 count：
  - 如果该元素和 base 相等，那么 count 自增 1
  - 否则将 base 更新为当前数字，count 复位为 1

- 然后更新 maxCount：
  - 如果 count=maxCount，说明当前的这个数字（base）出现的次数等于当前众数出现的次数，将 base 加入 answer 数组；
  - 如果 count>maxCount，说明当前的这个数字（base）出现的次数大于当前众数出现的次数，因此，需要将 maxCount 更新为 count，清空 answer 数组后将 base 加入 answer 数组。

可以把这个过程写成一个 update 函数。这样我们在寻找出现次数最多的数字的时候就可以省去一个哈希表带来的空间消耗。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.base = TreeNode()
        self.count = 0
        self.max_count = 0
        self.answer = []

    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        
        def dfs_bst(root):
            if not root:
                return None

            dfs_bst(root.left)
            update(root.val)
            dfs_bst(root.right)

        def update(value):
            if value == self.base:
                self.count += 1
            else:
                self.base = value
                self.count = 1
            
            if self.count == self.max_count:
                self.answer.append(self.base)
            elif self.count > self.max_count:
                self.max_count = self.count
                self.answer = [self.base]
            else:
                pass

        if not root:
            return root
        
        if not root.left and not root.right:
            return [root.val]

        dfs_bst(root)

        return self.answer
```

## 236. 二叉树的最近公共祖先

> https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。

> 示例 1：
>
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
>
> 输出：3
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
>
> 示例 2：
>
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
>
> 输出：5
>
> ![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
>
> 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近
>
> 公共祖先节点可以为节点本身。

求解思路：

终止条件：

- 当越过叶节点，则直接返回 null；
- 当 root 等于 p, q，则直接返回 root；

递推工作：

- 开启递归左子节点，返回值记为 left；
- 开启递归右子节点，返回值记为 right；

返回值： 根据 left 和 right ，可展开为四种情况；

- 当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p, q ，返回 null ；
- 当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
- 当 left 为空 ，right 不为空 ：p, q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：
  - p, q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
  - p, q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
- 当 left 不为空，right 为空：与情况 3. 同理；



> 参考：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        """
        """
        if not root:
            return None
        # 节点可以是其自身的祖先
        if p == root or q == root:
            return root
        # 需要返回值！
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        # 如果先序遍历完节点之后都为None，则说明不存在公共祖先
        if not left and not right:
            return None
        
        # 如果在左子树
        if left and not right:
            return left
        # 如果在右子树中
        if right and not left:
            return right
        # 如果分别在左右子树中
        if left and right:
            return root
```





注意事项：

1. 求最小公共祖先，需要从底向上遍历，那么二叉树只能通过后序遍历（即：回溯）实现从底向上的遍历方式。
2. 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
3. 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。

可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。

![236.二叉树的最近公共祖先2](https://img-blog.csdnimg.cn/202102041512582.png)

## 701. 二叉搜索树中的插入操作(递归or迭代)

> https://leetcode.cn/problems/insert-into-a-binary-search-tree

给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。输入数据和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。

求解思路：

如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。

![701.二叉搜索树中的插入操作](https://tva1.sinaimg.cn/large/008eGmZEly1gnbk63ina5g30eo08waja.gif)

例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6。

递归解法：

- 确定递归函数参数以及返回值：参数为根节点指针以及要插入的元素。可以利用返回值完成新加入的节点与其父节点的赋值操作。
- 确定终止条件：找到遍历的节点为null的时候，就是要插入节点的位置，把插入的节点返回。
- 确定单层递归的逻辑：搜索树是有方向了，可以根据插入元素的数值，决定递归方向。

```python

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)

        if val < root.val:
            root.left = self.insertIntoBST(root.left, val)
        
        if val > root.val:
            root.right = self.insertIntoBST(root.right, val)

        
        return root
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        
        que = [root]

        while que:
            node = que.pop(0)
            # 如果当前节点的值  > 目标值，则目标值需要插入到左子树
            if node.val > val:
                # 如果没有左子树，则创建，并退出
                if not node.left:
                    node.left = TreeNode(val)
                # 反之，移动到下一层，遍历
                else:
                    que.append(node.left)
                    # node = node.left
            # 反之，插入到右子树
            else:
                if not node.right:
                    node.right = TreeNode(val)
                else:
                    que.append(node.right)
                    # node = node.right

        return root
```

## 450. 删除二叉搜索树中的节点(递归)

> https://leetcode.cn/problems/delete-node-in-a-bst/

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点；
如果找到了，删除它。

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

求解思路：

1. 确定递归函数参数以及返回值
2. 确定终止条件：如果没找到删除的节点，直接返回；
3. 确定单层递归的逻辑：
   1. 没找到删除的节点，遍历到空节点直接返回；
   2. 找到删除的节点：
      1. 左右孩子都为空（叶子节点），直接删除，返回null作为根节点；
      2. 左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点；
      3. 右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点；
      4. 左右孩子都不为空，则将删除节点的左孩子放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

![450.删除二叉搜索树中的节点](https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif)


```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        # case1: 如果没找到要删除的节点，直接返回
        if not root:
            return root

        if root.val == key:
            # case2: 左右孩子都为空（叶子节点），直接删除节点，返回NULL为根节点
            if not root.left and not root.right:
                del root
                return None
            # case3: 左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
            if not root.left and root.right:
                tmp = root
                root = root.right
                del tmp
                return root
            # case4: 其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子根节点
            if root.left and not root.right:
                tmp = root
                root = root.left
                del tmp
                return root
            # case5: 左右孩子都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            else:
                v = root.right
                while v.left:
                    v = v.left
                v.left = root.left
                tmp = root
                root = root.right
                del tmp
                return root
        if root.val > key:
            root.left = self.deleteNode(root.left, key)
        if root.val < key:
            root.right = self.deleteNode(root.right, key)
        
        return root
```

## 669. 修剪二叉搜索树

> https://leetcode.cn/problems/trim-a-binary-search-tree/

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

求解思路（递归）：

1. 确定递归函数的参数以及返回值：通过递归函数的返回值来删除节点。
2. 确定终止条件：修剪的操作并不是在终止条件上进行的，所以遇到空节点返回即可。
3. 确定单层递归的逻辑：
   - 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。
   - 如果root的元素大于high的值，那么应该递归左子树，并返回左子树符合条件的头结点。
   - 接下来将下一层处理完左子树的结果赋给root->left，处理完右子树的结果赋给root->right，最后返回root节点。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: Optional[TreeNode], low: int, high: int) -> Optional[TreeNode]:
        if not root:
            return None
        
        if root.val < low:
            return self.trimBST(root.right, low, high)

        if root.val > high:
            return self.trimBST(root.left, low, high)

        if low <= root.val <= high:
            root.left = self.trimBST(root.left, low, high)
            root.right = self.trimBST(root.right, low, high)

            return root
```

## 108.将有序数组转换为二叉搜索树

> https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

求解思路：

**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。

因为已经排好序，所以选择中间元素作为根节点，分别递归左子树和右子树，满足条件。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        root = self.traversal(nums, 0, len(nums) - 1)
        return root
        

    def traversal(self, nums, left, right):
        if left > right:
            return None
        # 确定左右边界的中心
        mid = left + (right - left) // 2
        # 构建根节点
        mid_root = TreeNode(nums[mid])

        # 构建以左右边界的中心维分割点的左右子树
        mid_root.left = self.traversal(nums, left, mid-1)
        mid_root.right = self.traversal(nums, mid+1, right)

        return mid_root
```



## 538. 把二叉搜索树转换为累加树

> https://leetcode.cn/problems/convert-bst-to-greater-tree/

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

求解思路：**换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]。从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**。

本题依然需要一个pre指针记录当前遍历节点cur的前一个节点，这样才方便做累加。

1. 递归函数参数以及返回值：不需要递归函数的返回值，因为要遍历整棵树。同时，需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为int型。
2. 确定终止条件：遇到空就终止。
3. 确定单层递归的逻辑：注意**要右中左来遍历二叉树**，中节点的处理逻辑就是让cur的数值加上前一个节点的数值。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.pre = TreeNode(0)

    def convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        """
        倒序累加替换：  
        [2, 5, 13] -> [[2]+[1]+[0], [2]+[1], [2]] -> [20, 18, 13]
        """

        self.traversal(root)

        return root

    def traversal(self, root:TreeNode) -> None:
        # 因为要遍历整棵树，所以递归函数不需要返回值
        if not root:
            return None
        # 反向中序遍历
        self.traversal(root.right)  # 右

        root.val += self.pre.val  # 中
        self.pre = root

        self.traversal(root.left)  # 左
```

# 参考资料

> 《代码随想录》：https://github.com/youngyangyang04/leetcode-master

